import cv2
import numpy as np
from PIL import Image
from tqdm import tqdm
import zipfile
import struct
import argparse
import io
import os
import sys
import subprocess

# ==============================================================================
#  定数と設定
# ==============================================================================

# .mrvファイルに同梱するReadMeの内容
README_TEXT = """
This is an MRV file.
If you know, you know.

** WARNING: DO NOT EDIT THIS FILE MANUALLY **

You are looking at a .mrv file. Yes, we invented another video format. Why? Because we could.

[Technical Specifications]
- Container: ZIP (clever, right?)
- Video Stream (data.bin):
  - Header: Width(2), Height(2), FPS(1)
  - Palette: 256-color RGB, preceded by 0xFF marker (always 768 bytes, unused slots are zeroed)
  - Frame Data:
    - I-Frame: Raw indexed pixel data
    - P-Frame: Delta data (PaletteIndex, PixelIndex), preceded by 0xFE marker
- Compression: "Hopeful"
- Audio Stream: Not implemented. Silence is golden.

This format is a testament to what happens when a programmer asks "what if?" instead of "why?".
Playback is not guaranteed. Performance is questionable. We take no responsibility for melted CPUs.

"Maybe Runs Very-slowly" - A prophecy, not just a name.
...and, "Most Realstic Video", "Movie Rend Virtual", "More Ramem P(V)lease", "My Ridiculous Venture" etc.
(if you have more idea, lets contact @mecat254789 on X) (This "X" is XD)

<div style="font-size: 999px; color: red;">THIS TOOL MADE BY MECAT254788!!!</div>
(oops, I cannot use "tag")

// wait, can you see this?
# wait, wait, why?
<!-- maybe.. Is this .txt? -->
/* uhh */
[!-- How can I comment on txt? --] 
REM I dont know
<# If you have an idea, let's Join Microsoft #>[
You may find me listed as the author of a certain guide. In fact, I... oops, no more.


fun fact: The few MRVs produced early on contain texts that are "very valuable."
What's more: it's now available here!
「"Where are you from? MIT?"
"Yes, Mississippi Institute of Technology. Not over there."」

...(funny, right?)
oh, sorry. my mom is angry now.
good bye! see you! (and f**k you. First of all, why are you here? )
"""

# バイナリデータ用のマーカー
I_FRAME_MARKER = 0xFF  # キーフレーム（全データ）
P_FRAME_MARKER = 0xFE  # 差分フレーム

# ==============================================================================
#  ヘルパー関数
# ==============================================================================

def detect_scene_change(frame1_gray, frame2_gray, threshold: float) -> bool:
    """
    2つのグレースケールフレームを比較してシーンチェンジを検出する。
    ヒストグラムの相関を計算し、閾値を下回ったら変化があったとみなす。
    """
    if frame1_gray is None or frame2_gray is None:
        return True

    # ヒストグラムを計算
    hist1 = cv2.calcHist([frame1_gray], [0], None, [256], [0, 256])
    hist2 = cv2.calcHist([frame2_gray], [0], None, [256], [0, 256])
    
    # ヒストグラムを正規化
    cv2.normalize(hist1, hist1, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX)
    cv2.normalize(hist2, hist2, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX)

    # 相関を比較（値が1に近いほど似ている）
    correlation = cv2.compareHist(hist1, hist2, cv2.HISTCMP_CORREL)
    
    return correlation < threshold

# ==============================================================================
#  メインのエンコード処理
# ==============================================================================

def encode_mrv(input_path: str, output_path: str, width: int, scene_threshold: float, force_iframe_ratio: float, num_colors: int):
    """
    動画ファイルを読み込み、.mrvフォーマットにエンコードする。
    """
    # --- 1. 動画ファイルの読み込みと設定 ---
    cap = cv2.VideoCapture(input_path)
    if not cap.isOpened():
        print(f"エラー: 動画ファイルが開けません: {input_path}", file=sys.stderr)
        return

    original_fps = cap.get(cv2.CAP_PROP_FPS)
    original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    total_original_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    
    target_fps = 24
    if original_fps == 0:
        print("警告: 元動画のFPSが取得できませんでした。30FPSと仮定して処理を続行します。", file=sys.stderr)
        original_fps = 30.0

    # --- 2. 出力解像度の計算 ---
    aspect_ratio = original_height / original_width
    target_width = width
    target_height = int(target_width * aspect_ratio)

    # --- 3. ZIPとバイナリデータストリームの準備 ---
    mrv_data_stream = io.BytesIO()

    # --- 4. ヘッダ情報をバイナリに書き込み (Width, Height, FPS) ---
    header = struct.pack('<HHB', target_width, target_height, target_fps)
    mrv_data_stream.write(header)

    # --- 5. フレーム処理ループ ---
    previous_frame_gray = None
    previous_quantized_pixels = None
    current_palette_data = None
    
    total_target_frames = int(total_original_frames * (target_fps / original_fps))
    frame_indices_to_process = [int(i * (original_fps / target_fps)) for i in range(total_target_frames)]
    
    print(f"Original: {original_width}x{original_height} @ {original_fps:.2f} FPS ({total_original_frames} frames)")
    print(f"Target:   {target_width}x{target_height} @ {target_fps} FPS ({total_target_frames} frames)")
    print(f"Palette:  {num_colors} colors")
    print("-" * 30)

    for i in tqdm(range(total_target_frames), desc="Encoding to .mrv", unit="frame"):
        frame_index = frame_indices_to_process[i]
        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_index)
        ret, frame_bgr = cap.read()
        if not ret:
            break

        frame_rgb = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2RGB)
        pil_image = Image.fromarray(frame_rgb)
        pil_image_resized = pil_image.resize((target_width, target_height), Image.Resampling.LANCZOS)
        
        current_frame_gray = np.array(pil_image_resized.convert('L'))

        is_first_frame = (i == 0)
        is_scene_change = is_first_frame or detect_scene_change(previous_frame_gray, current_frame_gray, scene_threshold)
            
        if is_scene_change:
            quantized_image = pil_image_resized.quantize(colors=num_colors, method=Image.Quantize.FASTOCTREE)
            palette = quantized_image.getpalette()
            current_palette_data = bytes(palette[:256*3]) if palette else b'\x00' * 768
            current_quantized_pixels = np.array(quantized_image, dtype=np.uint8)
            
            mrv_data_stream.write(struct.pack('<B', I_FRAME_MARKER))
            mrv_data_stream.write(current_palette_data)
            mrv_data_stream.write(current_quantized_pixels.tobytes())
            
        else:
            palette_image = Image.new('P', (1, 1))
            palette_image.putpalette(current_palette_data)
            quantized_image = pil_image_resized.quantize(palette=palette_image, dither=Image.Dither.NONE)
            current_quantized_pixels = np.array(quantized_image, dtype=np.uint8)

            diff_indices = np.where(previous_quantized_pixels.flatten() != current_quantized_pixels.flatten())[0]
            
            num_pixels = target_width * target_height
            if len(diff_indices) > (num_pixels * force_iframe_ratio):
                quantized_image = pil_image_resized.quantize(colors=num_colors, method=Image.Quantize.FASTOCTREE)
                palette = quantized_image.getpalette()
                current_palette_data = bytes(palette[:256*3]) if palette else b'\x00' * 768
                current_quantized_pixels = np.array(quantized_image, dtype=np.uint8)
                
                mrv_data_stream.write(struct.pack('<B', I_FRAME_MARKER))
                mrv_data_stream.write(current_palette_data)
                mrv_data_stream.write(current_quantized_pixels.tobytes())
            else:
                mrv_data_stream.write(struct.pack('<B', P_FRAME_MARKER))
                mrv_data_stream.write(struct.pack('<I', len(diff_indices)))
                
                for idx in diff_indices:
                    new_palette_index = current_quantized_pixels.flat[idx]
                    delta_data = struct.pack('<BI', new_palette_index, idx)
                    mrv_data_stream.write(delta_data)

        previous_frame_gray = current_frame_gray
        previous_quantized_pixels = current_quantized_pixels

    cap.release()
    
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        zf.writestr('data.bin', mrv_data_stream.getvalue())
        zf.writestr('ReadMe,now.txt', README_TEXT)
        
    print("-" * 30)
    print(f"🎉 Success! MRV file created at: {output_path}")

# ==============================================================================
#  バッチ処理機能
# ==============================================================================

def batch_encode(width: int, colors: int, scene_threshold: float, force_iframe: float):
    """
    スクリプトと同じディレクトリにある全ての.mp4ファイルを検索し、
    指定された設定でエンコーダーを実行する。
    """
    try:
        script_path = os.path.abspath(__file__)
        script_dir = os.path.dirname(script_path)
    except NameError:
        script_dir = os.getcwd()

    mp4_files = [f for f in os.listdir(script_dir) if f.lower().endswith('.mp4')]

    if not mp4_files:
        print(f"エンコード対象の .mp4 ファイルがディレクトリに見つかりませんでした。\n({script_dir})")
        return

    total_files = len(mp4_files)
    print(f"Found {total_files} MP4 file(s) to encode with the following settings:")
    print(f"  Width: {width}, Colors: {colors}, Scene Threshold: {scene_threshold}, Force I-Frame: {force_iframe}")
    print("=" * 40)

    for i, filename in enumerate(mp4_files):
        input_path = os.path.join(script_dir, filename)
        output_filename = f"{os.path.splitext(filename)[0]}.mrv"
        output_path = os.path.join(script_dir, output_filename)
        
        print(f"[{i + 1}/{total_files}] Processing: {filename} -> {output_filename}")
        
        command = [
            sys.executable,
            script_path,
            input_path,
            "-o", output_path,
            "-w", str(width),
            "-c", str(colors),
            "-s", str(scene_threshold),
            "-f", str(force_iframe)
        ]
        
        try:
            subprocess.run(command, check=True)
        except subprocess.CalledProcessError as e:
            print(f"!!! '{filename}' のエンコード中にエラーが発生しました (エラーコード: {e.returncode})。", file=sys.stderr)
        except FileNotFoundError:
            print("!!! コマンドの実行に失敗しました。Pythonのパスが正しいか確認してください。", file=sys.stderr)
            break
        
        print("-" * 40)

    print("✅ Batch encoding process finished.")


# ==============================================================================
#  コマンドライン実行部分
# ==============================================================================

def check_color_range(value: str) -> int:
    try:
        ivalue = int(value)
        if not (2 <= ivalue <= 256):
            raise argparse.ArgumentTypeError(f"Color count must be between 2 and 256, but got {ivalue}.")
        return ivalue
    except ValueError:
        raise argparse.ArgumentTypeError(f"Invalid integer value: '{value}'.")

def main():
    parser = argparse.ArgumentParser(
        description="MP4 to MRV Encoder. Can run in single file or batch mode.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "input", nargs='?', default=None,
        help="Path to the input MP4 file. (Not needed with --batch)"
    )
    parser.add_argument(
        "-o", "--output", 
        help="Path for the output .mrv file. (Default: [input_filename].mrv)"
    )
    parser.add_argument(
        "-w", "--width", type=int, default=500, 
        help="Width of the output video in pixels. Height is auto-calculated. (Default: 500)"
    )
    parser.add_argument(
        "-c", "--colors", type=check_color_range, default=256,
        help="Number of colors in the palette (2-256). (Default: 256)"
    )
    parser.add_argument(
        "-s", "--scene-threshold", type=float, default=0.7, 
        help="Scene change detection threshold (0.0-1.0). Lower is more sensitive. (Default: 0.7)"
    )
    parser.add_argument(
        "-f", "--force-iframe", type=float, default=0.3,
        help="Force a keyframe if pixel changes exceed this ratio (0.0-1.0). (Default: 0.3)"
    )
    parser.add_argument(
        "--batch", action="store_true",
        help="Find and encode all .mp4 files in the current directory.\n'input' argument is ignored. Other options are applied to all files."
    )

    args = parser.parse_args()

    if args.batch:
        print("--- Batch Mode Activated ---")
        batch_encode(args.width, args.colors, args.scene_threshold, args.force_iframe)
    elif args.input:
        output_path = args.output
        if not output_path:
            base_name = os.path.splitext(os.path.basename(args.input))[0]
            output_path = f"{base_name}.mrv"
        
        encode_mrv(args.input, output_path, args.width, args.scene_threshold, args.force_iframe, args.colors)
    else:
        parser.print_help(sys.stderr)
        sys.stderr.write("\nError: You must provide an input file or use the --batch flag.\n")
        sys.exit(1)

if __name__ == '__main__':
    main()

# ==============================================================================
#  実行例 (コマンドラインから)
# ==============================================================================
#
# ■ シングルファイルモード
#
# 1. 基本的な使い方 (デフォルト設定でエンコード):
#    python encoder.py my_video.mp4
#
# 2. 出力ファイル名を指定:
#    python encoder.py my_video.mp4 -o encoded.mrv
#
# 3. 幅を320ピクセル、色数を64色に指定:
#    python encoder.py my_video.mp4 -w 320 -c 64
#
# 4. シーンチェンジ検出をより敏感に設定:
#    python encoder.py my_video.mp4 -s 0.5
#
# ■ バッチモード
#
# 1. カレントディレクトリ内の全ての.mp4をデフォルト設定でエンコード:
#    python encoder.py --batch
#
# 2. 全ての.mp4を幅300ピクセル、16色でエンコード:
#    python encoder.py --batch -w 300 -c 16
#