import cv2
import numpy as np
from PIL import Image
from tqdm import tqdm
import zipfile
import struct
import argparse
import io
import os
import sys
import subprocess

# ==============================================================================
#  å®šæ•°ã¨è¨­å®š
# ==============================================================================

# .mrvãƒ•ã‚¡ã‚¤ãƒ«ã«åŒæ¢±ã™ã‚‹ReadMeã®å†…å®¹
README_TEXT = """
This is an MRV file.
If you know, you know.

** WARNING: DO NOT EDIT THIS FILE MANUALLY **

You are looking at a .mrv file. Yes, we invented another video format. Why? Because we could.

[Technical Specifications]
- Container: ZIP (clever, right?)
- Video Stream (data.bin):
  - Header: Width(2), Height(2), FPS(1)
  - Palette: 256-color RGB, preceded by 0xFF marker (always 768 bytes, unused slots are zeroed)
  - Frame Data:
    - I-Frame: Raw indexed pixel data
    - P-Frame: Delta data (PaletteIndex, PixelIndex), preceded by 0xFE marker
- Compression: "Hopeful"
- Audio Stream: Not implemented. Silence is golden.

This format is a testament to what happens when a programmer asks "what if?" instead of "why?".
Playback is not guaranteed. Performance is questionable. We take no responsibility for melted CPUs.

"Maybe Runs Very-slowly" - A prophecy, not just a name.
...and, "Most Realstic Video", "Movie Rend Virtual", "More Ramem P(V)lease", "My Ridiculous Venture" etc.
(if you have more idea, lets contact @mecat254789 on X) (This "X" is XD)

<div style="font-size: 999px; color: red;">THIS TOOL MADE BY MECAT254788!!!</div>
(oops, I cannot use "tag")

// wait, can you see this?
# wait, wait, why?
<!-- maybe.. Is this .txt? -->
/* uhh */
[!-- How can I comment on txt? --] 
REM I dont know
<# If you have an idea, let's Join Microsoft #>[
You may find me listed as the author of a certain guide. In fact, I... oops, no more.


fun fact: The few MRVs produced early on contain texts that are "very valuable."
What's more: it's now available here!
ã€Œ"Where are you from? MIT?"
"Yes, Mississippi Institute of Technology. Not over there."ã€

...(funny, right?)
oh, sorry. my mom is angry now.
good bye! see you! (and f**k you. First of all, why are you here? )
"""

# ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ç”¨ã®ãƒãƒ¼ã‚«ãƒ¼
I_FRAME_MARKER = 0xFF  # ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆå…¨ãƒ‡ãƒ¼ã‚¿ï¼‰
P_FRAME_MARKER = 0xFE  # å·®åˆ†ãƒ•ãƒ¬ãƒ¼ãƒ 

# ==============================================================================
#  ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
# ==============================================================================

def detect_scene_change(frame1_gray, frame2_gray, threshold: float) -> bool:
    """
    2ã¤ã®ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ¯”è¼ƒã—ã¦ã‚·ãƒ¼ãƒ³ãƒã‚§ãƒ³ã‚¸ã‚’æ¤œå‡ºã™ã‚‹ã€‚
    ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®ç›¸é–¢ã‚’è¨ˆç®—ã—ã€é–¾å€¤ã‚’ä¸‹å›ã£ãŸã‚‰å¤‰åŒ–ãŒã‚ã£ãŸã¨ã¿ãªã™ã€‚
    """
    if frame1_gray is None or frame2_gray is None:
        return True

    # ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’è¨ˆç®—
    hist1 = cv2.calcHist([frame1_gray], [0], None, [256], [0, 256])
    hist2 = cv2.calcHist([frame2_gray], [0], None, [256], [0, 256])
    
    # ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’æ­£è¦åŒ–
    cv2.normalize(hist1, hist1, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX)
    cv2.normalize(hist2, hist2, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX)

    # ç›¸é–¢ã‚’æ¯”è¼ƒï¼ˆå€¤ãŒ1ã«è¿‘ã„ã»ã©ä¼¼ã¦ã„ã‚‹ï¼‰
    correlation = cv2.compareHist(hist1, hist2, cv2.HISTCMP_CORREL)
    
    return correlation < threshold

# ==============================================================================
#  ãƒ¡ã‚¤ãƒ³ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å‡¦ç†
# ==============================================================================

def encode_mrv(input_path: str, output_path: str, width: int, scene_threshold: float, force_iframe_ratio: float, num_colors: int):
    """
    å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€.mrvãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã€‚
    """
    # --- 1. å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã¨è¨­å®š ---
    cap = cv2.VideoCapture(input_path)
    if not cap.isOpened():
        print(f"ã‚¨ãƒ©ãƒ¼: å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ã¾ã›ã‚“: {input_path}", file=sys.stderr)
        return

    original_fps = cap.get(cv2.CAP_PROP_FPS)
    original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    total_original_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    
    target_fps = 24
    if original_fps == 0:
        print("è­¦å‘Š: å…ƒå‹•ç”»ã®FPSãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚30FPSã¨ä»®å®šã—ã¦å‡¦ç†ã‚’ç¶šè¡Œã—ã¾ã™ã€‚", file=sys.stderr)
        original_fps = 30.0

    # --- 2. å‡ºåŠ›è§£åƒåº¦ã®è¨ˆç®— ---
    aspect_ratio = original_height / original_width
    target_width = width
    target_height = int(target_width * aspect_ratio)

    # --- 3. ZIPã¨ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æº–å‚™ ---
    mrv_data_stream = io.BytesIO()

    # --- 4. ãƒ˜ãƒƒãƒ€æƒ…å ±ã‚’ãƒã‚¤ãƒŠãƒªã«æ›¸ãè¾¼ã¿ (Width, Height, FPS) ---
    header = struct.pack('<HHB', target_width, target_height, target_fps)
    mrv_data_stream.write(header)

    # --- 5. ãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†ãƒ«ãƒ¼ãƒ— ---
    previous_frame_gray = None
    previous_quantized_pixels = None
    current_palette_data = None
    
    total_target_frames = int(total_original_frames * (target_fps / original_fps))
    frame_indices_to_process = [int(i * (original_fps / target_fps)) for i in range(total_target_frames)]
    
    print(f"Original: {original_width}x{original_height} @ {original_fps:.2f} FPS ({total_original_frames} frames)")
    print(f"Target:   {target_width}x{target_height} @ {target_fps} FPS ({total_target_frames} frames)")
    print(f"Palette:  {num_colors} colors")
    print("-" * 30)

    for i in tqdm(range(total_target_frames), desc="Encoding to .mrv", unit="frame"):
        frame_index = frame_indices_to_process[i]
        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_index)
        ret, frame_bgr = cap.read()
        if not ret:
            break

        frame_rgb = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2RGB)
        pil_image = Image.fromarray(frame_rgb)
        pil_image_resized = pil_image.resize((target_width, target_height), Image.Resampling.LANCZOS)
        
        current_frame_gray = np.array(pil_image_resized.convert('L'))

        is_first_frame = (i == 0)
        is_scene_change = is_first_frame or detect_scene_change(previous_frame_gray, current_frame_gray, scene_threshold)
            
        if is_scene_change:
            quantized_image = pil_image_resized.quantize(colors=num_colors, method=Image.Quantize.FASTOCTREE)
            palette = quantized_image.getpalette()
            current_palette_data = bytes(palette[:256*3]) if palette else b'\x00' * 768
            current_quantized_pixels = np.array(quantized_image, dtype=np.uint8)
            
            mrv_data_stream.write(struct.pack('<B', I_FRAME_MARKER))
            mrv_data_stream.write(current_palette_data)
            mrv_data_stream.write(current_quantized_pixels.tobytes())
            
        else:
            palette_image = Image.new('P', (1, 1))
            palette_image.putpalette(current_palette_data)
            quantized_image = pil_image_resized.quantize(palette=palette_image, dither=Image.Dither.NONE)
            current_quantized_pixels = np.array(quantized_image, dtype=np.uint8)

            diff_indices = np.where(previous_quantized_pixels.flatten() != current_quantized_pixels.flatten())[0]
            
            num_pixels = target_width * target_height
            if len(diff_indices) > (num_pixels * force_iframe_ratio):
                quantized_image = pil_image_resized.quantize(colors=num_colors, method=Image.Quantize.FASTOCTREE)
                palette = quantized_image.getpalette()
                current_palette_data = bytes(palette[:256*3]) if palette else b'\x00' * 768
                current_quantized_pixels = np.array(quantized_image, dtype=np.uint8)
                
                mrv_data_stream.write(struct.pack('<B', I_FRAME_MARKER))
                mrv_data_stream.write(current_palette_data)
                mrv_data_stream.write(current_quantized_pixels.tobytes())
            else:
                mrv_data_stream.write(struct.pack('<B', P_FRAME_MARKER))
                mrv_data_stream.write(struct.pack('<I', len(diff_indices)))
                
                for idx in diff_indices:
                    new_palette_index = current_quantized_pixels.flat[idx]
                    delta_data = struct.pack('<BI', new_palette_index, idx)
                    mrv_data_stream.write(delta_data)

        previous_frame_gray = current_frame_gray
        previous_quantized_pixels = current_quantized_pixels

    cap.release()
    
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        zf.writestr('data.bin', mrv_data_stream.getvalue())
        zf.writestr('ReadMe,now.txt', README_TEXT)
        
    print("-" * 30)
    print(f"ğŸ‰ Success! MRV file created at: {output_path}")

# ==============================================================================
#  ãƒãƒƒãƒå‡¦ç†æ©Ÿèƒ½
# ==============================================================================

def batch_encode(width: int, colors: int, scene_threshold: float, force_iframe: float):
    """
    ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨åŒã˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚ã‚‹å…¨ã¦ã®.mp4ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ã—ã€
    æŒ‡å®šã•ã‚ŒãŸè¨­å®šã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
    """
    try:
        script_path = os.path.abspath(__file__)
        script_dir = os.path.dirname(script_path)
    except NameError:
        script_dir = os.getcwd()

    mp4_files = [f for f in os.listdir(script_dir) if f.lower().endswith('.mp4')]

    if not mp4_files:
        print(f"ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å¯¾è±¡ã® .mp4 ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n({script_dir})")
        return

    total_files = len(mp4_files)
    print(f"Found {total_files} MP4 file(s) to encode with the following settings:")
    print(f"  Width: {width}, Colors: {colors}, Scene Threshold: {scene_threshold}, Force I-Frame: {force_iframe}")
    print("=" * 40)

    for i, filename in enumerate(mp4_files):
        input_path = os.path.join(script_dir, filename)
        output_filename = f"{os.path.splitext(filename)[0]}.mrv"
        output_path = os.path.join(script_dir, output_filename)
        
        print(f"[{i + 1}/{total_files}] Processing: {filename} -> {output_filename}")
        
        command = [
            sys.executable,
            script_path,
            input_path,
            "-o", output_path,
            "-w", str(width),
            "-c", str(colors),
            "-s", str(scene_threshold),
            "-f", str(force_iframe)
        ]
        
        try:
            subprocess.run(command, check=True)
        except subprocess.CalledProcessError as e:
            print(f"!!! '{filename}' ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ (ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰: {e.returncode})ã€‚", file=sys.stderr)
        except FileNotFoundError:
            print("!!! ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚Pythonã®ãƒ‘ã‚¹ãŒæ­£ã—ã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚", file=sys.stderr)
            break
        
        print("-" * 40)

    print("âœ… Batch encoding process finished.")


# ==============================================================================
#  ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å®Ÿè¡Œéƒ¨åˆ†
# ==============================================================================

def check_color_range(value: str) -> int:
    try:
        ivalue = int(value)
        if not (2 <= ivalue <= 256):
            raise argparse.ArgumentTypeError(f"Color count must be between 2 and 256, but got {ivalue}.")
        return ivalue
    except ValueError:
        raise argparse.ArgumentTypeError(f"Invalid integer value: '{value}'.")

def main():
    parser = argparse.ArgumentParser(
        description="MP4 to MRV Encoder. Can run in single file or batch mode.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "input", nargs='?', default=None,
        help="Path to the input MP4 file. (Not needed with --batch)"
    )
    parser.add_argument(
        "-o", "--output", 
        help="Path for the output .mrv file. (Default: [input_filename].mrv)"
    )
    parser.add_argument(
        "-w", "--width", type=int, default=500, 
        help="Width of the output video in pixels. Height is auto-calculated. (Default: 500)"
    )
    parser.add_argument(
        "-c", "--colors", type=check_color_range, default=256,
        help="Number of colors in the palette (2-256). (Default: 256)"
    )
    parser.add_argument(
        "-s", "--scene-threshold", type=float, default=0.7, 
        help="Scene change detection threshold (0.0-1.0). Lower is more sensitive. (Default: 0.7)"
    )
    parser.add_argument(
        "-f", "--force-iframe", type=float, default=0.3,
        help="Force a keyframe if pixel changes exceed this ratio (0.0-1.0). (Default: 0.3)"
    )
    parser.add_argument(
        "--batch", action="store_true",
        help="Find and encode all .mp4 files in the current directory.\n'input' argument is ignored. Other options are applied to all files."
    )

    args = parser.parse_args()

    if args.batch:
        print("--- Batch Mode Activated ---")
        batch_encode(args.width, args.colors, args.scene_threshold, args.force_iframe)
    elif args.input:
        output_path = args.output
        if not output_path:
            base_name = os.path.splitext(os.path.basename(args.input))[0]
            output_path = f"{base_name}.mrv"
        
        encode_mrv(args.input, output_path, args.width, args.scene_threshold, args.force_iframe, args.colors)
    else:
        parser.print_help(sys.stderr)
        sys.stderr.write("\nError: You must provide an input file or use the --batch flag.\n")
        sys.exit(1)

if __name__ == '__main__':
    main()

# ==============================================================================
#  å®Ÿè¡Œä¾‹ (ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰)
# ==============================================================================
#
# â–  ã‚·ãƒ³ã‚°ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰
#
# 1. åŸºæœ¬çš„ãªä½¿ã„æ–¹ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰):
#    python encoder.py my_video.mp4
#
# 2. å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŒ‡å®š:
#    python encoder.py my_video.mp4 -o encoded.mrv
#
# 3. å¹…ã‚’320ãƒ”ã‚¯ã‚»ãƒ«ã€è‰²æ•°ã‚’64è‰²ã«æŒ‡å®š:
#    python encoder.py my_video.mp4 -w 320 -c 64
#
# 4. ã‚·ãƒ¼ãƒ³ãƒã‚§ãƒ³ã‚¸æ¤œå‡ºã‚’ã‚ˆã‚Šæ•æ„Ÿã«è¨­å®š:
#    python encoder.py my_video.mp4 -s 0.5
#
# â–  ãƒãƒƒãƒãƒ¢ãƒ¼ãƒ‰
#
# 1. ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®å…¨ã¦ã®.mp4ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰:
#    python encoder.py --batch
#
# 2. å…¨ã¦ã®.mp4ã‚’å¹…300ãƒ”ã‚¯ã‚»ãƒ«ã€16è‰²ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰:
#    python encoder.py --batch -w 300 -c 16
#